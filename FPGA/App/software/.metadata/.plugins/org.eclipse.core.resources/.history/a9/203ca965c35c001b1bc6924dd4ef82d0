#include <stdio.h>
#include <altera_avalon_pio_regs.h>
#include <sys/alt_irq.h>
#include <sys/alt_stdio.h>
#include <altera_msgdma.h>
#include "controller.hpp"
#include "driver/adc2.hpp"
#include "driver/imu.hpp"
#include "microshell/core/microshell.h"
#include "microshell/util/mscmd.h"
#include "microshell/util/ntlibc.h"
#include "driver/led.hpp"
#include "driver/load_switch.hpp"
#include "peripheral/motor_controller.hpp"
#include "peripheral/vector_controller.hpp"

static uint32_t xorshift(void) {
    static uint32_t x = 123456789;
    static uint32_t y = 362436069;
    static uint32_t z = 521288629;
    static uint32_t w = 88675123;
    uint32_t t;
    t = x ^ (x << 11);
    x = y; y = z; z = w;
    return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
}

void Pulse1kHzHandler(void *context) {
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(PIO_0_BASE, 0);
    static int cnt = 0;
    ++cnt;
    if (cnt == 50){
        Led::SetMotor5Enabled(true);
    }
    else if (100 <= cnt){
        cnt = 0;
        Led::SetMotor5Enabled(false);
    }

    static struct {
        uint16_t frame_number = 0;
        uint16_t pio1_data;
        int16_t mc1_power;
        int16_t adc1_u_data_1;
        int16_t adc1_v_data_1;
        uint16_t pos_error;
        uint16_t pos_theta;
        int16_t current_d;
        int16_t current_q;
    } payload;

    uint32_t adc1_data = IORD_ALTERA_AVALON_PIO_DATA(PIO_3_BASE);
    uint32_t pos_data = IORD_ALTERA_AVALON_PIO_DATA(PIO_4_BASE);
    payload.frame_number++;
    payload.pio1_data = (IORD_ALTERA_AVALON_PIO_DATA(PIO_1_BASE) >> 8) & 0x7;
    payload.mc1_power = MotorController::GetPower();
    payload.adc1_u_data_1 = adc1_data >> 16;
    payload.adc1_v_data_1 = adc1_data & 0xFFFF;
    payload.pos_error = pos_data >> 16;
    payload.pos_theta = pos_data & 0xFFFF;
    payload.current_d = VectorController::GetCurrentMeasurementD(1);
    payload.current_q = VectorController::GetCurrentMeasurementQ(1);

    alt_u32 option = (0x72 << ALTERA_MSGDMA_DESCRIPTOR_CONTROL_TRANSMIT_CHANNEL_OFFSET) | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GENERATE_SOP_MASK | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MASK;
    alt_msgdma_standard_descriptor desc;
    alt_msgdma_dev *dev = alt_msgdma_open(MSGDMA_0_CSR_NAME);
    alt_msgdma_construct_standard_mm_to_st_descriptor(dev, &desc, reinterpret_cast<uint32_t*>(&payload), sizeof(payload), option);
    alt_msgdma_standard_descriptor_sync_transfer(dev, &desc);
}

static MSCMD_USER_RESULT command_imu(MSOPT *msopt, MSCMD_USER_OBJECT usrobj) {
    ImuResult_t result;
    IMU::ReadData(&result);
    printf("Accel(%d, %d, %d) Gyro(%d, %d, %d)\n", result.AccelDataX, result.AccelDataY, result.AccelDataZ, result.GyroDataX, result.GyroDataY, result.GyroDataZ);
    return 0;
}

static MSCMD_USER_RESULT command_adc2(MSOPT *msopt, MSCMD_USER_OBJECT usrobj) {
    int p48v = Adc2::GetDC48V();
    int dribble = Adc2::GetDribbleCurrent();
    printf("P48V=%dmV Idribble=%dmA\n", p48v, dribble);
    return 0;
}

static MSCMD_USER_RESULT command_power(MSOPT *msopt, MSCMD_USER_OBJECT usrobj) {
    int argc;
    msopt_get_argc(msopt, &argc);
    if (argc == 1){
        printf("Power=>%d\n", MotorController::GetPower());
    }
    else if (argc == 2){
        char buf[MSCONF_MAX_INPUT_LENGTH];
        msopt_get_argv(msopt, 1, buf, sizeof(buf));
        int value = ntlibc_atoi(buf);
        MotorController::ClearFault();
        VectorController::ClearFault();
        MotorController::SetPower(value);
        VectorController::SetCurrentReferenceD(1, 0);
        VectorController::SetCurrentReferenceQ(1, -value);
        printf("Power<=%d\n", MotorController::GetPower());
    }
    return 0;
}

/*static MSCMD_USER_RESULT command_phase(MSOPT *msopt, MSCMD_USER_OBJECT usrobj) {
    int argc;
    msopt_get_argc(msopt, &argc);
    if (argc == 4) {
        char buf[MSCONF_MAX_INPUT_LENGTH];
        msopt_get_argv(msopt, 1, buf, sizeof(buf));
        msopt_get_argv(msopt, 2, buf + 1, sizeof(buf) - 1);
        msopt_get_argv(msopt, 3, buf + 2, sizeof(buf) - 2);
        Led::SetMotor3Enabled(buf[0] == '1');
        Led::SetMotor2Enabled(buf[1] == '1');
        Led::SetMotor1Enabled(buf[2] == '1');
        printf("Phase<=%c%c%c\n", buf[0], buf[1], buf[2]);
    }
    return 0;
}*/

static MSCMD_USER_RESULT command_switch(MSOPT *msopt, MSCMD_USER_OBJECT usrobj) {
    int argc;
    msopt_get_argc(msopt, &argc);
    if (argc == 2) {
        char buf[MSCONF_MAX_INPUT_LENGTH];
        msopt_get_argv(msopt, 1, buf, sizeof(buf));
        LoadSwitch::SetMotor1Enabled(buf[0] == '1');
        printf("Switch<=%c\n", buf[0]);
    }
    return 0;
}

static MSCMD_USER_RESULT command_fault(MSOPT *msopt, MSCMD_USER_OBJECT usrobj) {
    printf("PIO1=%08X\n", IORD_ALTERA_AVALON_PIO_DATA(PIO_1_BASE));
    printf("Mc1Status=%04X\n", MotorController::GetStatus().Status);
    printf("VecStatus=%04X\n", VectorController::GetStatus().Status);
    return 0;
}

static void msgdma_callback(void *context) {
    struct alt_msgdma_dev *p_msgdma = (alt_msgdma_dev*)context;
    printf( "<Debug> mSGDMA Callback Function called!!\n" );
    // mSGDMA の コントロール・レジスタ と ステータス・レジスタ の値を取得
    int nCtrl = IORD_ALTERA_MSGDMA_CSR_CONTROL( p_msgdma->csr_base );
    int nStat = IORD_ALTERA_MSGDMA_CSR_STATUS( p_msgdma->csr_base );
    // 指定バイト数分転送完了したか?
    if ( nStat & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK) {
        // Yes: 転送完了フラグを立てる
        //xfer_cmp = TRUE;
    } else {
        // それ以外の割り込みはエラーとする
        //xfer_err = TRUE;
        printf( " mSGDMA_IRQ: stat_reg=%X. ctrl_reg=%X\n", nStat, nCtrl );
    }
}

static MSCMD_USER_RESULT command_transport(MSOPT *msopt, MSCMD_USER_OBJECT usrobj) {
    alt_msgdma_dev *dev = alt_msgdma_open(MSGDMA_0_CSR_NAME);
    if (dev == nullptr) {
        printf("mSGDMA was not found\n");
        return 0;
    }
    alt_msgdma_register_callback(dev, msgdma_callback, ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK | ALTERA_MSGDMA_CSR_STOP_ON_EARLY_TERMINATION_MASK, dev);

    uint32_t data[32];
    int channel_count = xorshift() % 4;
    for(int i = 0; i <= channel_count; i++){
        int channel = xorshift() % 256;
        int length = (xorshift() % sizeof(data)) + 1;
        int length_u32 = (length + 3) >> 2;
        for(int j = 0; j < length_u32; j++){
            data[j] = xorshift();
        }
        alt_u32 option = ALTERA_MSGDMA_DESCRIPTOR_CONTROL_TRANSFER_COMPLETE_IRQ_MASK;
        option |= channel << ALTERA_MSGDMA_DESCRIPTOR_CONTROL_TRANSMIT_CHANNEL_OFFSET;
        if (i == 0) option |= ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GENERATE_SOP_MASK;
        if (i == channel_count) option |= ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MASK;
        alt_msgdma_standard_descriptor desc;
        alt_msgdma_construct_standard_mm_to_st_descriptor(dev, &desc, reinterpret_cast<uint32_t*>(data), length, option);
        if (alt_msgdma_standard_descriptor_sync_transfer(dev, &desc) != 0){
            printf("Failed to transfer\n");
        }
    }

    return 0;
}

static MSCMD_COMMAND_TABLE command_table[] = {
    {"imu", command_imu},
    {"adc", command_adc2},
    {"power", command_power},
    //{"phase", command_phase},
    {"switch", command_switch},
    {"fault", command_fault},
    {"tx", command_transport}
};


// IRQ handlers
// msgdma_0    IRQ0, RIL=1, RRS=1
// timer_0     IRQ1, RIL=3, RRS=3
// pio_0       IRQ2, RIL=2, RRS=2
// pio_1       IRQ3, RIL=3, RRS=3
// jtag_uart_0 IRQ4, RIL=1, RRS=1
// i2cm_0      IRQ5, RIL=1, RRS=1
// spim_0      IRQ6, RIL=1, RRS=1
// spim_1      IRQ7, RIL=1, RRS=1
// vcm_0       IRQ8, RIL=3, RRS=3
// mc_0        IRQ9, RIL=3, RRS=3

static void initialize_peripheral(void) {
    IMU::Initialize();
    Adc2::Initialize();
    //Controller::Initialize();
}

static void start_peripheral(void) {
    Adc2::Start();
    IOWR_ALTERA_AVALON_PIO_IRQ_MASK(PIO_0_BASE, Pio0Pulse1kHz);  // bit0の割り込みを許可
    IOWR_ALTERA_AVALON_PIO_EDGE_CAP(PIO_0_BASE, 0);              // pio_0のエッジ検知フラグをクリア
    alt_ic_isr_register(PIO_0_IRQ_INTERRUPT_CONTROLLER_ID, PIO_0_IRQ, Pulse1kHzHandler, nullptr, nullptr);
    //Controller::Start();
}

int main(void) {
    // 割り込みを一時禁止してペリフェラルとハードウェアの初期化を行う
    auto context = alt_irq_disable_all();
    initialize_peripheral();
    start_peripheral();
    alt_irq_enable_all(context);

    // MicroShellを初期化する
    char buf[64];
    MICROSHELL ms;
    MSCMD mscmd;
    microshell_init(
        &ms,
        [](char c) { alt_putchar(c); },
        [](void) -> char { return alt_getchar(); },
        nullptr);
    mscmd_init(&mscmd, command_table, sizeof(command_table) / sizeof(command_table[0]), nullptr);

    // 起動メッセージを表示する
    alt_putstr("Hello from Nios II!\n");

    // コマンド入力を受け付ける
    while (true) {
        alt_putchar('>');
        microshell_getline(&ms, buf, sizeof(buf));
        MSCMD_USER_RESULT result;
        mscmd_execute(&mscmd, buf, &result);
    }

    return 0;
}
